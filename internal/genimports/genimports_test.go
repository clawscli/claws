package genimports

import (
	"strings"
	"testing"
)

func TestGenerateConstantsFile(t *testing.T) {
	tests := []struct {
		name     string
		pkgName  string
		service  string
		resource string
		wantPkg  string
		wantPath string
	}{
		{
			name:     "simple package",
			pkgName:  "instances",
			service:  "ec2",
			resource: "instances",
			wantPkg:  "package instances",
			wantPath: `const ServiceResourcePath = "ec2/instances"`,
		},
		{
			name:     "hyphenated resource",
			pkgName:  "trainingjobs",
			service:  "sagemaker",
			resource: "training-jobs",
			wantPkg:  "package trainingjobs",
			wantPath: `const ServiceResourcePath = "sagemaker/training-jobs"`,
		},
		{
			name:     "hyphenated service and resource",
			pkgName:  "knowledgebases",
			service:  "bedrock-agent",
			resource: "knowledge-bases",
			wantPkg:  "package knowledgebases",
			wantPath: `const ServiceResourcePath = "bedrock-agent/knowledge-bases"`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := string(GenerateConstantsFile(tt.pkgName, tt.service, tt.resource))

			if !strings.HasPrefix(got, "// Code generated by go generate; DO NOT EDIT.") {
				t.Error("missing generated code header")
			}
			if !strings.Contains(got, "// To regenerate: task gen-imports") {
				t.Error("missing regenerate instruction")
			}
			if !strings.Contains(got, tt.wantPkg) {
				t.Errorf("want package %q in output", tt.wantPkg)
			}
			if !strings.Contains(got, tt.wantPath) {
				t.Errorf("want constant %q in output", tt.wantPath)
			}
			if !strings.Contains(got, "// ServiceResourcePath is the canonical path") {
				t.Error("missing doc comment for constant")
			}
		})
	}
}

func TestGetServiceDisplayName(t *testing.T) {
	tests := []struct {
		service string
		want    string
	}{
		{"ec2", "EC2"},
		{"s3", "S3"},
		{"lambda", "Lambda"},
		{"bedrock-agent", "Bedrock Agent"},
		{"cloudformation", "CloudFormation"},
		{"unknown", "Unknown"},
	}

	for _, tt := range tests {
		t.Run(tt.service, func(t *testing.T) {
			got := GetServiceDisplayName(tt.service)
			if got != tt.want {
				t.Errorf("GetServiceDisplayName(%q) = %q, want %q", tt.service, got, tt.want)
			}
		})
	}
}

func TestGroupByService(t *testing.T) {
	packages := []string{
		"github.com/clawscli/claws/custom/ec2/instances",
		"github.com/clawscli/claws/custom/ec2/volumes",
		"github.com/clawscli/claws/custom/s3/buckets",
		"github.com/clawscli/claws/custom/lambda/functions",
	}

	grouped := GroupByService(packages)

	if len(grouped["ec2"]) != 2 {
		t.Errorf("ec2 should have 2 packages, got %d", len(grouped["ec2"]))
	}
	if len(grouped["s3"]) != 1 {
		t.Errorf("s3 should have 1 package, got %d", len(grouped["s3"]))
	}
	if len(grouped["lambda"]) != 1 {
		t.Errorf("lambda should have 1 package, got %d", len(grouped["lambda"]))
	}
}

func TestGetPackageInfo(t *testing.T) {
	tests := []struct {
		name       string
		importPath string
		wantSvc    string
		wantRes    string
		wantDir    string
	}{
		{
			name:       "simple",
			importPath: "github.com/clawscli/claws/custom/ec2/instances",
			wantSvc:    "ec2",
			wantRes:    "instances",
			wantDir:    "custom/ec2/instances",
		},
		{
			name:       "hyphenated resource",
			importPath: "github.com/clawscli/claws/custom/sagemaker/training-jobs",
			wantSvc:    "sagemaker",
			wantRes:    "training-jobs",
			wantDir:    "custom/sagemaker/training-jobs",
		},
		{
			name:       "hyphenated service",
			importPath: "github.com/clawscli/claws/custom/bedrock-agent/agents",
			wantSvc:    "bedrock-agent",
			wantRes:    "agents",
			wantDir:    "custom/bedrock-agent/agents",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			info := GetPackageInfo("", tt.importPath)

			if info.Service != tt.wantSvc {
				t.Errorf("Service = %q, want %q", info.Service, tt.wantSvc)
			}
			if info.Resource != tt.wantRes {
				t.Errorf("Resource = %q, want %q", info.Resource, tt.wantRes)
			}
			if info.DirPath != tt.wantDir {
				t.Errorf("DirPath = %q, want %q", info.DirPath, tt.wantDir)
			}
			if info.ImportPath != tt.importPath {
				t.Errorf("ImportPath = %q, want %q", info.ImportPath, tt.importPath)
			}
		})
	}
}

func TestGetPackageInfoFallbackPackageName(t *testing.T) {
	info := GetPackageInfo("", "github.com/clawscli/claws/custom/sagemaker/training-jobs")

	if info.PackageName != "trainingjobs" {
		t.Errorf("PackageName = %q, want %q", info.PackageName, "trainingjobs")
	}
}
